<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/09/技术总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Miss huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/09/技术总结/" itemprop="url">技术总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-09T21:44:06+08:00">
                2018-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><blockquote>
<p>全拼：Hyper Text Mark-up Language 超文本标记语言<br>1.&lt; &gt; 是所有标记的开始和结束<br>2.标记之间可以嵌套,例如<code>&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;</code><br>3.注释：<!-- -->ctrl+shift+?</p>
</blockquote>
<h5 id="HTML与XHTML区别"><a href="#HTML与XHTML区别" class="headerlink" title="HTML与XHTML区别"></a>HTML与XHTML区别</h5><p>1.XHTML比HTML更严格，所有主流览器都支持XHTML<br>2.XHTML文档必须有XHTML DOCTYPE声明<br>3.XHTML元素必须正确被嵌套<br>4.XHTML元素始终是关闭的，空元素也必须正确被关闭<br>5.XHTML必须是小写<br>6.XHTML属性值必须加引号</p>
<h5 id="HTML为什么要语义化"><a href="#HTML为什么要语义化" class="headerlink" title="HTML为什么要语义化"></a>HTML为什么要语义化</h5><p>1.屏幕阅读器会根据你的标记来阅读你的网页<br>2.PDA、手机等设备可能无法像电脑浏览器一样来渲染网页（通常是因为这些设备对css的支持较弱）<br>3.有利于SEO优化<br>4.便于团队的开发和维护</p>
<h5 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h5><p>1.由<code>&lt;html&gt;</code>元素定义文档版本信息<br>2.由<code>&lt;head&gt;</code>定义各项声明的文档头部信息<br>3.由<code>&lt;body&gt;</code>定义文档的主体部分</p>
<p>2.1<code>&lt;head&gt;&lt;/head&gt;</code>包括标题，基础信息和元信息，作用范围是整篇，内容显示在网页上方<br>2.2<code>&lt;title&gt;&lt;/title&gt;</code>用来说明页面的用途，显示在浏览器的标题栏中，放在<code>&lt;head&gt;&lt;/head&gt;</code>之间<br>2.3<code>&lt;meta/&gt;</code>放在<code>&lt;head&gt;&lt;/head&gt;</code>之间，meta信息不显示在页面中，一般用来定义页面信息的说明，关键字等；可以有多个meta元素，属性有name，主要用来描述网页，便于搜索引擎查找，分类<br>语法：<code>&lt;meta name=&quot;keywords&quot; content=&quot;输入具体的关键字&quot;&gt;</code><br>语法：<code>&lt;meta name=&quot;description&quot; content=&quot;设置页面说明&quot;&gt;</code><br>语法：<code>&lt;meta name=&quot;generator&quot; content=&quot;编辑工具&quot;&gt;</code><br>语法：<code>&lt;meta name=&quot;author content=&quot;作者名&quot;&gt;</code><br>语法：<code>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html&quot;; charset=&quot;编码格式&quot;/&gt;或&lt;meta charset=&quot;utf-8&quot;&gt;</code><br>语法：<code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;跳转的时间;URL=跳转到的地址&quot;&gt;</code></p>
<p>3.1标题标签 <code>&lt;h1&gt;~&lt;h5&gt;</code>  文字水平对齐text-align   文字行距中对齐line-height  字体大小font-size   粗体b strong   斜体i em   上标sup    下标  sub   下划线u    换行br  横线hr<br>宽width   高height   阴影shade    空格&amp;nbsp   版权&amp;copy<br>3.2有序列表 <code>&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code>   无序列表<code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code>   表格<code>&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code>   表格内文字与边框间距cellpadding   合并行rowspan   合并列colspan    </p>
<h5 id="1-说说行内元素和块级元素的区别，如何转化？"><a href="#1-说说行内元素和块级元素的区别，如何转化？" class="headerlink" title="1.说说行内元素和块级元素的区别，如何转化？"></a>1.说说行内元素和块级元素的区别，如何转化？</h5><p>块级元素：默认占整行，宽度如果不设置，会继承父级，支持所有css样式的设置。行内元素：只占自己本身的宽度和高度，不支持宽度和高度的设置，上下的padding只是表面的现象。<br>行元素和块元素的转化：<br>块元素转化为行元素display:inline,转化后的块元素只是具有了行元素的特征，但只是显示为块元素，本身还是行元素<br>行元素转化为块元素display:block,转化后的行元素只是具有了块元素的特征，但只是显示为行元素，本身还是块元素<br>转化为行内块元素display:inline-block,此元素可以设置宽高，又可让多个元素在一行显示。</p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h5 id="css简介"><a href="#css简介" class="headerlink" title="css简介"></a>css简介</h5><ul>
<li>css指层叠样式表（Cascading Style Sheets）</li>
<li>样式通常存储在样式表中，大大提高了工作效率</li>
<li>css样式有三种引入方式  外部样式表    内部样式表     内联样式</li>
</ul>
<h5 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h5><ul>
<li>id选择器</li>
<li>类选择器</li>
<li>标签选择器</li>
<li>兄弟选择器</li>
<li>子选择器</li>
<li>伪类选择器</li>
<li>群组选择器</li>
<li>通用选择器</li>
</ul>
<h5 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h5><ul>
<li>content padding(外边框) border margin(外边距) </li>
</ul>
<h5 id="css定位"><a href="#css定位" class="headerlink" title="css定位"></a>css定位</h5><ul>
<li>relative<br>元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 </li>
<li>absolute<br>元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 </li>
<li>fixed<br>元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。<br>提示：相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。</li>
<li>浮动<br>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</li>
</ul>
<h5 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h5><p>（1）    给父级加高度<br>（2）    clear:left;right;both<br>（3）    加一个空的div<br>（4）    给父级加display:inline-block<br>（5）    加<code>&lt;br/&gt;</code><br>（6）    Overflow；hidden<br>（7）    伪类after</p>
<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><p>HTML5 是下一代的 HTML。</p>
<h5 id="H5建立的一些规则"><a href="#H5建立的一些规则" class="headerlink" title="H5建立的一些规则"></a>H5建立的一些规则</h5><ul>
<li>新特性应该基于 HTML、CSS、DOM 以及 JavaScript。 </li>
<li>减少对外部插件的需求（比如 Flash） </li>
<li>更优秀的错误处理 </li>
<li>更多取代脚本的标记 </li>
<li>HTML5 应该独立于设备 </li>
<li>开发进程应对公众透明 </li>
</ul>
<h5 id="HTML5中的新特性："><a href="#HTML5中的新特性：" class="headerlink" title="HTML5中的新特性："></a>HTML5中的新特性：</h5><ul>
<li>用于绘画的 canvas 元素 </li>
<li>用于媒介回放的 video 和 audio 元素 </li>
<li>对本地离线存储的更好的支持 </li>
<li>新的特殊内容元素，比如 article、footer、header、nav、section </li>
<li>新的表单控件，比如 calendar、date、time、email、url、search </li>
</ul>
<h5 id="H5视频"><a href="#H5视频" class="headerlink" title="H5视频"></a>H5视频</h5><p>vidao 包含的属性 autoplay视频在就绪的时候播放  controls显示控件  loop循环   </p>
<p><video width="320" height="240" controls="controls"><br>  <source src="movie.ogg" type="video/ogg"><br>  <source src="movie.mp4" type="video/mp4"><br>Your browser does not support the video tag.<br></video><br>play()播放    pause()暂停</p>
<h5 id="H5音频"><a href="#H5音频" class="headerlink" title="H5音频"></a>H5音频</h5><p>audio 包含的属性 autoplay视频在就绪的时候播放  controls显示控件  loop循环   </p>
<audio controls="controls"><br>  <source src="song.ogg" type="audio/ogg"><br>  <source src="song.mp3" type="audio/mpeg"><br>Your browser does not support the audio tag.<br></audio>

<h5 id="H5拖拽"><a href="#H5拖拽" class="headerlink" title="H5拖拽"></a>H5拖拽</h5><p>拖拽API<br>拖拽API是h5的新特性<br>拖拽：drag<br>释放：drop<br>拖拽指的是鼠标点击原对象后一直移动对象不松手，一旦松手即释放了。<br>源对象：指的是我们鼠标点击的一个事物，这里可以是一张图片，一个div，一段文本等。<br>目标对象：指的是我们拖动源对象后移动到一块区域，源对象可以进入到这个区域，可以在这个区域上方悬停（未松手），可以松手释放源对象放置此处（一松手），也可以悬停后离开该区域<br>拖拽API相关 的函数<br>被拖拽的源对象可以触发的事件<br>1）ondragstart：原对象开始被拖动<br>2）ondrag:源对象被拖拽过程中（鼠标可能移动也可能未移动）<br>3）ondragend:源对象拖动结束</p>
<p>拖动源对象进入到上方目标对象可以触发的事件<br>1）ondragenter:目标对象被源对象拖动这进入；<br>2）ondragover:目标对象呗源对象拖动这悬停在上方<br>3）ondragleave:源对象拖动这离开目标对象<br>4）ondrop:源对象拖动着目标对象上方释放,放手</p>
<p>e.clientX 相对于可视区的坐标                    chrome   ff  opera  safari ie9及以上<br>e.pageX   相对于整个页面的坐标（加滚动条） chrome   ff  opera  safari  ie9及以上<br>e.offsetX 相对于当前坐标系的border左上角开始的坐标<br>e.layerX  相对于当前坐标系的border左上角开始的坐标 //存储数据<br>如何在拖动的源对象事件和目标事件中传递数据<br>e.dataTransfer{}数据传递对象<br>功能：用于在源对象和目标对象的事件间传递数据<br>源对象的事件处理中保留数据<br>e.datetransfer.satData(k,v)k,v必须是string类型<br>目标对象的事件处理中读取数据<br>var v=e.dataTransfer.getData(k);<br>处理浏览器的默认行为<br>e.preventdefult;</p>
<h5 id="H5画布"><a href="#H5画布" class="headerlink" title="H5画布"></a>H5画布</h5><p>HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。<br>画布是一个矩形区域，您可以控制其每一像素。<br>canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。<br>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：<br>            var c=document.getElementById(“myCanvas”);<br>            var cxt=c.getContext(“2d”);<br>            cxt.fillStyle=”#FF0000”;<br>            cxt.fillRect(0,0,150,75); </p>
<p>beginPath()开始绘画<br>closePath()结束<br>moveTo(100,100)<br>lineTo(300,300)<br>strokeStyle形状线条的颜色<br>fillStyle内部区域的颜色<br>fill()将路径绘制为填充<br>stroke()将路径绘制为轮廓形状<br>fillRect（x,y,width,height） 绘制实心矩形<br>strokeRcct（x,y,width,height）绘制矩形路径<br>clearRect（x,y,width,height）擦除矩形<br>save()保存画布的属性和状态<br>restore()恢复画布属性和状态<br>scale()缩放画布<br>translate()重新映射画布原点，改变上一次原点的位置<br>rotaate()旋转当前画布，公式为degrees*Math.PI / 180;<br>createLinearGradient(x1,y1,x2,y2): 线性渐变<br>createRadialGradient(x1,y1,r1,x2,y2,r2): 径向渐变<br>arc(x，y，radius，startAngle，endAngle，direction)画圆</p>
<h5 id="H5结构标记"><a href="#H5结构标记" class="headerlink" title="H5结构标记"></a>H5结构标记</h5><p><code>&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;section&gt;&lt;/section&gt;&lt;aside&gt;&lt;/aside&gt;&lt;footer&lt;/footer&gt;&lt;hgroup&gt;&lt;/hgroup&gt;</code></p>
<h5 id="cookies，sessionStorage和localStorage的区别"><a href="#cookies，sessionStorage和localStorage的区别" class="headerlink" title="cookies，sessionStorage和localStorage的区别"></a>cookies，sessionStorage和localStorage的区别</h5><ul>
<li>cookies<br>数据的生命周期：<br>一般由服务器生成，可设置失效时间，关闭浏览器后失效<br>存储大小：<br>4K<br>与服务器端的通信：<br>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来    性能问题<br>易用性：<br>需要程序员自己封装，原生的cookie接口不好</li>
<li>localStorage<br>数据的生命周期：<br>除非被清除，否则永远保存<br>存储大小：<br>5mb<br>与服务器的通信<br>仅在客户端（即浏览器）保存，不参与与服务器的通信<br>易用性：<br>原生接口可以接受，也可以再次封装来对object和array更好的支持</li>
<li>sessionStorage<br>数据的生命周期：<br>仅在当前会话下有效，关闭页面或者浏览器后被清除<br>存储大小：<br>5mb<br>与服务器的通信<br>仅在客户端（即浏览器）保存，不参与服务器的通信<br>易用性：<br>原生接口可以接受，也可以再次封装来对object和array更好的支持。</li>
</ul>
<h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><p>最重要的 CSS3 模块包括：<br>选择器<br>框模型<br>背景和边框<br>文本效果<br>2D/3D 转换<br>动画<br>多列布局<br>用户界面 </p>
<h5 id="CSS3-1"><a href="#CSS3-1" class="headerlink" title="CSS3"></a>CSS3</h5><p>border-radius    box-shadow   text-shadow  word-wrap    text-wrap   </p>
<h5 id="CSS3转化"><a href="#CSS3转化" class="headerlink" title="CSS3转化"></a>CSS3转化</h5><ul>
<li>transition  过渡<ul>
<li>参数一：过渡的时间   s 代表秒    ms毫秒</li>
<li>参数二：过渡的属性（默认是过度所有的属性）all代表所有的属性</li>
<li>参数三：过渡的方式   ease(默认的)减速运动  linear匀速    ease-in加速 ease-out减速  ease-in-out先加速后减速</li>
</ul>
</li>
<li>transform:变换<br>translate() rotate() scale()  skew()</li>
</ul>
<h5 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h5><ul>
<li>animation<br>@keyframes代表关键帧   name是自定义命名<br>animation动画<br>参数一：时间<br>参数二：关键帧的名字<br>参数三：运动 的方式<pre><code>ease   默认的减速
linear 匀速的
ease-in  加速
ease-out 减速
ease-in-out 先加速后减速
</code></pre>参数四：重复的次数<pre><code>         数字
infinite 无限次
</code></pre>参数五：动画的顺序<pre><code>nomoal 正常
alternate  顺时针 逆时针   偶数的次数会照着走   第一次0%-100%第二次100%-0%
</code></pre>动画的暂停<br>animation-play-state:表示动画的状态<br>参数一：paused  暂停<br>参数二：runnning 播放 </li>
</ul>
<h5 id="CSS3新增选择器"><a href="#CSS3新增选择器" class="headerlink" title="CSS3新增选择器"></a>CSS3新增选择器</h5><p>属性选择器li[color=”blue”]<code>&lt;li color=&quot;blue&quot;&gt;blue&lt;/li&gt;</code><br>伪类选择器nth-child(n)隔行变色 odd代表选择奇数 even代表选择偶数<br>nth-of-type(n)  target: 目标伪类  E:frist-line  E标签里第一行文字的状态<br>E:first-letter E标签里的第一个文字的状态<br>E::selection  E标签里文字被选中的状态（双冒号是css3里的固定伪类语法）<br>E:before     在E标签的最前面添加内容<br>E:after     在E标签的最后边添加内容<br>E:not(s)排除掉某一元素</p>
<h5 id="自适应网站的写法"><a href="#自适应网站的写法" class="headerlink" title="自适应网站的写法"></a>自适应网站的写法</h5><p>自适应网站（响应式）  可以在一个网站上，显示不同的屏幕分辨率的效果<br><code>&lt;mate name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;/&gt;</code><br>viewport  是网站默认的宽度和高度<br>网页的宽度默认等于屏幕的宽度和高度<br>原始比例缩放为1.0（initial-scale=1)即网页初始大小占屏幕面积的100%<br>所有的主流浏览器都支持自适应，包括IE9以上的   IE678不支持   需要使用css3-mediaqueries.js;<br>[if lt IE 9]<br><code>&lt;script src=&quot;http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js&quot;&gt;&lt;/script&gt;</code><br>[endif]<br>不能使用绝对的宽度<br>由于网页根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，包括元素也不能使用 width:xx%    width:auto</p>
<pre><code>* @media screen and (max-width:500px) {
 body{
 background:blue;
 color:#fff;
 font-size:5rem;
 }
 }
</code></pre><p>and左右必须有空格</p>
<p>#JavaScript</p>
<h6 id="JavaScript的组成"><a href="#JavaScript的组成" class="headerlink" title="JavaScript的组成"></a>JavaScript的组成</h6><p>ECMAScript(5.1) 核心<br>DOM文档对象模型 描述处理网页内容的方法和接口<br>BOM浏览器对象模型 描述浏览器进行交互的方法和接口</p>
<h5 id="JS的特点"><a href="#JS的特点" class="headerlink" title="JS的特点"></a>JS的特点</h5><p>跨平台的脚本语言</p>
<h5 id="JS的引入方式"><a href="#JS的引入方式" class="headerlink" title="JS的引入方式"></a>JS的引入方式</h5><p>外部脚本块  引入外部文件 src里的路径不允许写中文 script标签中不许放内容 多个文件可以公用一个  js文件，可以提高效率<br>内部脚本块  一般写在body head部分 可以把样式和结构分离出来 但只能在当前页面使用<br>行间样式    写的比较简单 但是后期维护率高 不利于后期维护 </p>
<h5 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h5><p>允许是子母数字下划线美元任意组合  不允许数字开头  不允许关键字和保留字来命名</p>
<h5 id="js函数"><a href="#js函数" class="headerlink" title="js函数"></a>js函数</h5><p>命名函数<br>匿名函数</p>
<h5 id="js属性"><a href="#js属性" class="headerlink" title="js属性"></a>js属性</h5><p>1.点   元素.属性名  获取到的结果是他的属性值<br>2.[]  可以用中括号代替点，里边可以放带横杆的属性，但是必须把横杆去了,把横杆后的第一个字母大写</p>
<h5 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h5><pre><code>数据类型                 检测结果（type of）
String                  string
Number                  number
Boolean                 boolean
Null                    object
Undefined               undefined
Object                  object
function                function
</code></pre><h5 id="流程语句"><a href="#流程语句" class="headerlink" title="流程语句"></a>流程语句</h5><ul>
<li>if<br>if(判断条件){ <em> 当判断条件成立的时候，会执行这里的代码 </em> } <em> if 如果 当页面中只有一种特殊情况去处理的时候 </em> else 否则 当页面中有两种特殊情况要去处理的时候 <em> </em> 语法 <em> if(判断条件){ </em> //当条件成立的时候，执行这里的代码 * }</li>
<li>for循环<br>for(条件初始化;条件判断;条件变化){ <em> 当条件成立的时候（true）,重复执行这里的代码 </em> } <em> 分号不能少 </em> <em> for循环的一个步骤 </em> 第一步：条件初识话（声明了一个变量，给了这个变量一个初始值） <em> var i=0; </em> <em> 第二步：走的是条件判断（把变量的值限定在一个范围内） </em> i&lt;10;第三步：走的是大括号里的代码（当条件判断成立的时候，走大括号里边的代码，走不走取决于第二步的判断为true的时候才走 console.log(‘villom’);第四步：条件变化（循环一次让变量的值加1） i++;<br>注意 从第二次开始，它就不走第一步了，不断走第二步，第三步，第四步</li>
<li>swith<pre><code>swich(变量){
 case 值:
 当这个值与变量的值相同的时候，才会走这里的代码
 break;停止以下代码继续执行
 case 值:
 当这个值与变量的值相同的时候，才会走这里的代码
 break;停止以下代码继续执行
 case 值:
 当这个值与变量的值相同的时候，才会走这里的代码
 break;停止以下代码继续执行
 default:备选条件
 当以上变量都不满足的时候，会执行这里的代码
 }
</code></pre></li>
<li>while<pre><code>while(条件判断){
    当条件满足的时候，会循环这里的代码
}
</code></pre></li>
</ul>
<h5 id="break-continue-return区别"><a href="#break-continue-return区别" class="headerlink" title="break continue return区别"></a>break continue return区别</h5><pre><code>break
停止循环，剩下的循环就不会走了（break后面的代码是不会执行的）
continue
停止循环，只不过它停止的是当前的循环，后面的循环还是会走的
return
返回，让函数停止执行,它只能用在函数内
return后面的代码是不会执行的
break  continue return 三个功能都是停止循环， break continue只能         用在循环当中
return 只能用在函数内
</code></pre><h5 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h5><p>1.在函数外面的时候 this指向window<br>2.函数是直接被调用的 this指向window 被事件调用,并且是以赋值的形式出现 this指向 谁调用它,this就指向谁 </p>
<h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>1.重复执行定时器<br>      setInterval(function(){<br>      每隔一段时间就会执行这里的代码<br>      },时间)<br>2.延迟执行定时器<br>       setTimeout(function(){<br>       当时间到达后，会执行这里的代码<br>       },时间)<br>3.清除定时器的方法</p>
<ul>
<li>清除重复执行定时器<br>clearInterval(定时器的返回值)</li>
<li>清除延时定时器<br>clearTimeout(定时器的返回值)</li>
</ul>
<h5 id="日期对象（js内置方法，用于处理时间和日期的相关操作）"><a href="#日期对象（js内置方法，用于处理时间和日期的相关操作）" class="headerlink" title="日期对象（js内置方法，用于处理时间和日期的相关操作）"></a>日期对象（js内置方法，用于处理时间和日期的相关操作）</h5><p>new Date() 创建日期对象  可以接受参数<br>1.没有参数<br> 它是以本机的时间作为参考，创建一个日期对象<br>2.new Date(年,月,日,时,分,秒);<br> 参数是数字，每个参数用逗号来隔开<br> 注意：参数是可以省略的，不一定要全部写，省略的部分会默认为0，除了日期，日期的默认为1<br>3.new Date(‘June 10,2013 12:12:12’);<br> 参数是字符串，外国人常用的日期表达方式<br>4.new Date(时间戳);<br> 参数是时间戳<br> 时间戳：从1970年1月1日0时0分0秒，到指定一个时间点之间的毫秒数<br>5.获取日期对象<br>     日期对象.getFullYear();   获取年<br>     日期对象.getMonth();      获取月，月份从0开始的，11 代表的是12月份   10  代表的是11月<br>     日期对象.getDate();       获取日<br>     日期对象.getDay();        获取星期   从0开始，0代表周日，一周的第一天是周日<br>     日期对象.getHours();      获取小时<br>     日期对象.getMinutes();    获取分钟<br>     日期对象.getSeconds();    获取秒<br>     日期对象.getMilliseconds();    获取毫秒<br>     日期对象.getTime();       获取时间戳（单位：毫秒）<br>6.设置日期对象<br>    获取日期对象<br>    日期对象.setFullYear();   获取年<br>    日期对象.setMonth();      获取月，月份从0开始的，11 代表的是12月份   10  代表的是11月<br>    日期对象.setDate();       获取日<br>    日期对象.setHours();      获取小时<br>    日期对象.setMinutes();    获取分钟<br>    日期对象.setSeconds();    获取秒<br>    日期对象.setMilliseconds();    获取毫秒<br>    日期对象.setTime();       获取时间戳（单位：毫秒）</p>
<h5 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h5><pre><code>charAt通过索引找字符
charCodeAt通过索引值找字符，找到后转成Unicode编码
indexOf 通过字符找下标（从左到右找这个字符首次出现的位置）
slice截取字符串
split用指定的分隔符把字符串隔成数组
subString 截取一段字符串
subStr 截取一段指定开始位置和个数的字符串
</code></pre><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><pre><code>Unshift给数组前面添加数
pop删除数组最后一个数据
shift删除数字第一个数据
push给数组末尾添加数据
concat连接数组，组成新的数组
reverse颠倒数组
join将数组中的所有元素连成字符串
slice截取数组
</code></pre><h5 id="Math方法"><a href="#Math方法" class="headerlink" title="Math方法"></a>Math方法</h5><pre><code>Math.ceil
Math.floor
Math.round
Math.abs
Math.random
</code></pre><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p> DOM 关于  创建  插入  修改  删除页面的元素的标准<br> 赋予我们操作页面的能力<br> DOM 页面的内容都是字符串，js会把这些字符串转成dom树<br> DOM树会把字符串转成节点，其实我们操作DOM的根本就是在操作节点</p>
<h5 id="属性节点"><a href="#属性节点" class="headerlink" title="属性节点"></a>属性节点</h5><pre><code>parentNode 当前节点的唯一的直接父节点对象
childNode  当前节点的所有子节点，组成一个类数组
children   从父级找子级，找到的是一个集合
nextElementSibling 当前节点的下一个兄弟节点
previousElementSibling 找到上一个兄弟节点
offsetParent  获取离元素最近的有定位的父级
offsetleft    获取离元素最近的到左边有定位的父级的距离，不带单位，也不带边框
createElement 创建元素节点
appendChild   追加节点
cloneNode     克隆节点
removeChild   移除元素
getBoundingClientRect().left获取元素盒模型的一些信息，得到的结果是没有单位，并且不包含滚动条的距离
getAttribute  得到属性
setAttribute  设置属性
removeAttribute 移除属性
insetbefore     插入元素
replceChild     替换元素
元素.offsetWidth 获取元素的宽 含padding border 不带单位
元素.clientWidtn 获取元素的宽 含padding 不含border 不带单位
document.documentElement.clientWidth获取可视区的宽
document.body.scrollTop||document.documentElement.scrollTop滚动条的距离
</code></pre><h5 id="innerHTML和DOM的区别"><a href="#innerHTML和DOM的区别" class="headerlink" title="innerHTML和DOM的区别"></a>innerHTML和DOM的区别</h5><pre><code>innerHTMl
作用
它会把原来的内容清空，再添加新的内容，而被添加的原来的内容已经没有了
DOM方法
会把新的内容追加到原来的内容的里面，原来的内容所具有的事件依然会在，不会受影响
</code></pre><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM 是关于浏览器的方法，属性，事件<br>window.open()<br> 参数<br> 1.代表要打开的新网页的地址<br> 2.打开方式，是在本页面打开还是另外一个页面打开_black  _self  _iframName<br>_self  在本窗口打开<br>_black 在新窗口打开<br>_iframName  在一个网页里面嵌套另一个网页<br> 3.打开新窗口的位置信息<br>window.close（）关闭页面<br>window.location<br>BOM方法可视区的宽和高window.innerWidth<br>屏幕的宽和高 window.screen.width<br>滚动条的距离 window.pageXOffset横向滚动条<br>设置滚动条的距离 window.scrollTo(x,y)<br>window.onscroll()监测滚动条的方法</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>鼠标事件<br>键盘事件<br>系统事件<br>表单事件</p>
<h5 id="鼠标坐标"><a href="#鼠标坐标" class="headerlink" title="鼠标坐标"></a>鼠标坐标</h5><p>event.clientX   事件发生的时候，鼠标的X轴位置信息   代表的当前的位置距离左边的距离<br>event.clientY   事件发生的时候，鼠标的Y轴位置信息   代表的当前的位置距离上边的距离</p>
<h5 id="事件源"><a href="#事件源" class="headerlink" title="事件源"></a>事件源</h5><p>event.target<br>它会一层一层往里面去找，直到找到最里面的那个元素<br>谁触发了这个事件，特别是页面中有一堆嵌套的层，如果在这个嵌套的层上点击了以下，我们能准确的找到事件的源对象<br>点击蓝色找到span 点击绿色 找到P 点击红色 找到的源对象是div 事件源是有变化  所以并不是事件写给谁谁就是事件源<br>事件委托或者事件代理<br>就是一件事委托给另外的元素去做了，在当前的案例中 我们把li的事件委托给ul</p>
<h5 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h5><p>1.on<br>  方法<br>  对象.on事件名称=函数<br>  注意：on只能给元素添加一个事件，如果有多个on，那后面的就会把前面给覆盖掉<br>2.addEventListener() 系统当中内置的一个方法<br>  方法<br>  对象.addEventListener(事件名称，事件绑定函数，布尔值);<br>  参数：<br>  参数一：事件名称  不加on,它是一个字符串，加引号 click  mousemove<br>  参数二：事件绑定函数，可以是匿名函数，也可以是命名函数<br>  参数三：布尔值  事件流  一个完整的事件其实都发生了三个阶段   捕获阶段  目标阶段   冒泡阶段<br>    false  表示事件是在冒泡阶段发生的   默认的<br>    true   表示事件是在捕获阶段发生的<br>    事件绑定函数里的this是指向事件触发的对象，而不是指向window</p>
<h5 id="事件移除"><a href="#事件移除" class="headerlink" title="事件移除"></a>事件移除</h5><p>1.移除on添加的事件<br>  对象.on事件名称=null;<br>2.移除addEventListener添加的事件<br>  对象.removeEventListener(事件名称，事件绑定函数，布尔值);<br>  注意：removeEventListener不能移除匿名函数事件，只能移除命名函数事件</p>
<h5 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h5><p> 事件流是指事件在触发时的一个流程，就像for循环一样有一个执行的过程<br> 在事件触发时，会先执行一个阶段叫做“捕获阶段”，从最外层向触发该元素寻找的一个过程，<br> 最终找到触发该事件的元素，如果该元素有绑定事件处理函数则执行该函数，<br> 在找到触发该事件的元素之后，如果元素身上有事件，就会执行事件，称为“目标阶段”<br> 接下来会进入到下一阶段“冒泡阶段”，冒泡阶段是从目标元素的上一层开始往外寻找，直到<br> 最外层时结束整个事件流程<br> 无论是捕获阶段还是冒泡阶段，在寻找目标元素的过程中和向外返回的过程中，所遇到的每一个元素<br> 身上如果有同一个事件处理函数都会被调用<br> 事件的整个流程 三个阶段<br> 1.捕获阶段   capture 从外往里找，不管你点击的是哪一个元素，它都会从最高级window找起，一层一层往下走<br> 2.目标阶段   target  第二个阶段<br> 3.冒泡阶段  bubbling 从里往外走<br>注意：IE浏览器的低版本只能绑定在冒泡阶段</p>
<h5 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h5><p>1.阻止on事件<br>event.cancelBubble=true;属性<br>2.阻止addEventListener事件<br>event.stopPropagation();方法</p>
<h5 id="浏览器的默认行为"><a href="#浏览器的默认行为" class="headerlink" title="浏览器的默认行为"></a>浏览器的默认行为</h5><p>1.去除on事件的默认行为<br> 在函数里边写   return false;<br>2.去除addEventListener事件的默认行为<br> 在函数里调用  event.preventDefault();方法<br>3.去除拖拽<br> 元素.ondragstart=function(){return false};<br>4.去除右击<br> 元素.oncontextmenu=function(){return false};</p>
<h5 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h5><p>1.鼠标按下 mousedown<br> 需要计算出鼠标点击的地方离元素边界的距离<br> 鼠标起始X轴的距离=event.clientX-box.offsetLeft;<br> 鼠标起始Y轴的距离=event.clientY-box.offsetTop;<br>2.鼠标移动 mousemove<br> 算出元素的真正的left值和top值<br> box.style.left=event.clientX-鼠标起始X轴的距离;<br> box.style.top=event.clientY-鼠标起始Y轴的距离；<br>3.鼠标抬起 mouseup<br> 清除鼠标身上的事件，清空事件，为后面做铺垫</p>
<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>jQuery是js库，把常用的一些功能给封装好了，用它规定的API方法调用就好；知道它提供的方法是干嘛的就行；提供了很强大的选择器，简介的API，优雅的链式，便捷的操作。核心理念：写的少，做更多</p>
<h5 id="jQuery加载"><a href="#jQuery加载" class="headerlink" title="jQuery加载"></a>jQuery加载</h5><p>（1）$(callBack);<br>（2）$(document).ready(callBack);<br>（3）$().ready(callBack);<br>jQuery获取到的元素都是集合<br>获取元素的方法$(元素)<br>用原生获取到的方法是不能用jquery里边的方法，如果想用的话，那就把原生获取到的元素转成jquery的形式</p>
<h5 id="jQuery事件（没有on）"><a href="#jQuery事件（没有on）" class="headerlink" title="jQuery事件（没有on）"></a>jQuery事件（没有on）</h5><p>例如：$(‘selector’).click(callback);在事件里的this是原生的，如果要用this转成jquery的形式$(this);</p>
<h5 id="css-方法"><a href="#css-方法" class="headerlink" title="css();方法"></a>css();方法</h5><p>关于样式的一些操作<br>一个参数，获取元素的值<br>两个参数，设置属性的值<br>同时设置更多属性<br>一个参数，如果这个参数是对象，表示设置属性，同时可以设置多个属性的值<br>表单的value值：$(元素).val()  没有参数是获取value的值，写参数是设置value的值</p>
<h5 id="attr-和data-方法"><a href="#attr-和data-方法" class="headerlink" title="attr();和data();方法"></a>attr();和data();方法</h5><p>1.attr();关于标签属性的操作<br>一个参数，表示获取元素的某个属性，参数的值是属性的名字<br>两个参数，设置元素的某个属性<br>          第一个参数为属性名字，第二个参数为属性的值<br>2.data();给标签添加数据<br>有参数的话，是添加数据（用对象的形式表示）；<br>没有参数的话，是获取数据</p>
<h4 id="html-和text-方法"><a href="#html-和text-方法" class="headerlink" title="#html();和text();方法"></a>#html();和text();方法</h4><ol>
<li>html();更改内容，相当于原生的innerHTML,解析成真正的标签<br>2.text();更改内容，不会解析成真正的标签<h5 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h5>对一个元素进行连续的操作<h5 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h5>1.first(); 获取第一个子节点    无参数<br>2.last(); 获取最后一个子节点   无参数<br>3.slice(start,end);截取部分子节点<br>start 截取开始的位置，end截取结束的位置（含头不含尾）<br>一个参数   从当前到结尾<br>4.children();获取到元素里边第一层子节点<br>没有参数，获取到父级下所有的第一层子节点<br>有参数，参数的选择器，找到的是对应选择器节点<br>5.find();获取元素的所有子节点<br>6.父节点<br>（1）parent(); 元素的第一层父节点<br>（2）parents();元素所有的父节点，它会一层一层往外找，直到找到最外层的父节点<br>7.最近节点<br>closest(‘selector’);<br>从自身找，一层一层往外找父级，找到最近的满足条件的元素，找到一个后就不找了<h5 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h5>第一种：<br>父级.append(要添加的元素)；把要添加的元素添加到父级最后面<br>父级.prepend(要添加的元素)；把要添加的元素添加到父级最前面<br>元素.before(要添加的元素)把要添加的元素添加到指定元素的前面<br>元素.after(要添加的元素)；把要添加的元素添加到指定元素的后面<br>第二种：<br>要添加的元素.appendTo(父级)；把要添加的元素添加到父级最后面<br>要添加的元素.prependTo(父级)；把要添加的元素添加到父级最前面<br>要添加的元素.insertbefore(元素)；把要添加的元素添加到指定元素的前面<br>要添加的元素.insertafter(元素)；把要添加的元素添加到指定元素的后面<h5 id="移除节点和克隆节点"><a href="#移除节点和克隆节点" class="headerlink" title="移除节点和克隆节点"></a>移除节点和克隆节点</h5>1.元素.remove(); 删除元素    没有参数<br>2.clone(blooen);克隆元素<br>参数默认为空，只复制元素，不复制事件<br>参数为true，元素月事件都会复制<h5 id="上一个和下一个兄弟节点"><a href="#上一个和下一个兄弟节点" class="headerlink" title="上一个和下一个兄弟节点"></a>上一个和下一个兄弟节点</h5></li>
<li>上一个兄弟节点，prve();</li>
<li>下一个兄弟节点，next();<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5>index();<br>没有参数，第一个元素（获取到的元素，因为jquery获取到的是一组），在兄弟元素中的排行<br>有参数，代表前面的元素在参数的标签（所有标签，不分兄弟）里排第几，返回-1说明没有找到<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5>each(i,elem);  循环的方法<br>i   每个元素对应的下标(索引值)<br>elem 每个元素，原生的元素<br>在循环中elem是原生的元素，对象要转成jquery对象<br>循环当中要跳出循环，用return  false<h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5>get(index)  把jquery对象转原生对象<pre><code>index 索引值
原生转jquery对象用$();
</code></pre>  jquery转原生对象用get(index);<h5 id="包装对象-（在外面包一层标签）"><a href="#包装对象-（在外面包一层标签）" class="headerlink" title="包装对象 （在外面包一层标签）"></a>包装对象 （在外面包一层标签）</h5>wrap(); 在标签外面加一层父级<br>wrapAll(); 把所有的标签拿过来放在一起。给他在外面加一层父级，是根据第一个标签来定结构的<br>wrapInner(); 在父级里添加一个标签，并把内容放在这个标签里边<br>unwrap()；删除父级<h5 id="元素与可视区尺寸"><a href="#元素与可视区尺寸" class="headerlink" title="元素与可视区尺寸"></a>元素与可视区尺寸</h5>不带单位<br>width()获取元素的宽度<br>height()获取元素的高度 <pre><code>有参数，代表设置元素的宽与高，参数不带单位
</code></pre>outerWidth();   width+padding+border  相当与原生的offsetWidth<br>outerHeight();  height+padding+border  相当与原生的offsetHeight<br>innerWidth()    width+padding  相当与原生的clientWidth<br>innerHeight()   height+padding  相当与原生的clientHeight<h5 id="可视区的宽高"><a href="#可视区的宽高" class="headerlink" title="可视区的宽高"></a>可视区的宽高</h5>1.整个页面，带滚动条<br>$(document).width();页面的宽<br>$(document).height();页面的高<br>2.$(window).width();可视区的宽<br>$(window).height();可视区的高<h5 id="元素的距离"><a href="#元素的距离" class="headerlink" title="元素的距离"></a>元素的距离</h5>offset().left<br>offset().top<br>相当于原生里的getBoundingClientRect<br>到可视区的距离<br>元素相对于父级的距离<br>position().left    相当于原生里的offsetLeft<br>position().top<br>offsetParent();最近的有定位的父级<h5 id="滚动条的距离"><a href="#滚动条的距离" class="headerlink" title="滚动条的距离"></a>滚动条的距离</h5>srollTop（）滚动条的高度<br>srollLeft（）滚动条的宽度<br>没有参数，代表获取滚动条距离<br>有参数代表设置滚动条的距离<br>滚轮事件：$(document).scroll(function(){});<h5 id="事件及事件对象"><a href="#事件及事件对象" class="headerlink" title="事件及事件对象"></a>事件及事件对象</h5>juery的事件<br>通过eddEventListener添加的事件<br>几个事件是同时加载，是不会被覆盖的<br>#####jquery运动<br>jquery写好的运动库，只留给方法，会用后可以<br>Show（duration，easing，complate）显示<br>Hide（duration，easing，complate）隐藏<br>Duration 时间<br>Slow   600毫秒 慢<br>Normal 400毫秒 正常<br>Fast   200毫秒 快<br>Easing 运动的方式<br>Linear匀速<br>Swing缓冲<br>complate运动完成之后的回调函数<br>toggle（duration，easing，complate）在两种效果之间切换<br>toggle它会参数display的值，让运动在显示和隐藏之间切换，它在运动时会切换宽高透明度等属性<br>fadeIn（duration，easing，complate）显示<br>fadeOut（duration，easing，complate）隐藏<br>fadeToggle（duration，easing，complate）<br>收缩与展开<br>slideUp（duration，easing，complate）收缩<br>slideDown（duration，easing，complate）展开<br>slideToggle（duration，easing，complate）显示<br>animate（property，duration，easing，complate）<br>property  要运动的属性  它是一个对象<br>duration  运动的时间<br>easing    运动方式<br>   Linear匀速<br>   Swing  缓冲<br>Complate  回调函数<br>Stop（）停止动画<br>Stop（）没有参数，只停止当前属性的运动，后面的运动不会走<br>Stop（true）有参数所有的运动都停止了<br>Stop（true，true）当前的运动会直接走到目标点，后面的运动不会走<br>Finish（）停止，不接受参数，所有的属性都会马上到达目标点，没有运动效果，后面的运动并不会走<br>问题移入移出的时候触发多次，它就必须运行多少次<br>Stop（），解决办法：在鼠标放上去的时候，先让当前的运动停止了<br>Plugins插件<br>Validate表单插件<br>Rules代表规则<br>Required表示是否要验证true要验证 false不用验证用户名<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1>ajax是一种技术方案，但不是一种新技术，它依赖现有的css/html/javascript,而其中最核心依赖的是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出http请求和接收http请求<h1 id="jsonp-json-padding"><a href="#jsonp-json-padding" class="headerlink" title="jsonp(json+padding)"></a>jsonp(json+padding)</h1>1.通过script标签引入某些数据，是同步模式，只有上面的代码加载完成才能继续加载下面的代码一般用在script标签做跨域的时候，<br>不建议数据提前加载，应该按需加载<br>2.当需要数据是创建一个script标签，将需要的数据放在src中，通过onload去监听是否请求过来，请求完毕就调用传过来的数据<br>3.jsonp不能用post请求只能用get请求<h1 id="git与github"><a href="#git与github" class="headerlink" title="git与github"></a>git与github</h1>git是目前最先进的分布式版本控制系统，它在本地电脑里<br>github是一个社交平台，开源项目，是一个远程仓库<br>1、下载<br><a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">https://git-for-windows.github.io/</a><br>2、在开始里打开Git Bash<br>接下来要做的是把git绑定github<br>3、打开github网站登录后<br>1、点击最右上角的图标，点击settings<br>2、再打开的页面左边点击SSH and GPG keys选项<br>3、点击New SSH key<br>4、在打开的页面里随便输入一个title<br>4、找key<br>在打开的软件(Git Bash)里输入ssh-keygen -t rsa -C ‘注册的邮箱’<br>1、点击回车后提示要输入密码，可以输入也可以不输入<br>2、接下来两次回车就可以，从提示的路径里找到对应的.ssh文件<br>3、打开对应的路径，里面有两个id_rsa，打开带pub的那个id_rsa（里面带邮箱），复制里面的代码<br>5、所复制的key放到网页里面，点击确定<br>6、测试有没有绑定成功<br>输入命令ssh -T git@github.com<br>有提示 <code>You have successfully authenticated</code>就表示绑定成功<br>7、设置用户信息（用于在提交的时候显示你的信息）<br>查看的话，如果没有设置过的话什么也没有，查看也可以用git config –list<br>设置用户名输入git config –global user.name ‘用户名’<br>设置用户邮箱输入git config –global user.email ‘邮箱’<br>8、建立项目（可能会提示输入密码）<br>1、点击网站中右上角的加号<br>2、点击弹出来框里面的New repository<br>3、在Repository name输入框里输入项目名称<br>4、在Description输入框里输入项目描述<br>5、把Initialize this repository with a README的框打上对号，表示把项目的描述也放在文件夹里<br>9、把项目放到本地<br>1、在本地新建一个文件夹<br>2、在命令提示框里找到新建的目录，用cd命令cd c:    cd:github(tab可以补全)<br>3、git clone 项目地址<br>项目地址在网页里点击clone or download的绿色按钮弹出的输入框里复制一下<br>等命令提示框里看到一个100%就证明已经下载完成了<br>注意：下载后的文件里有一个隐藏的.git文件夹，不要去修改它，不然会出错的<br>10、在项目里新建页面<br>1、要看这个文件下有哪些文件，输入ls<br>2、进入到Tab的文件，cd Tab<br>地址里有一个master，表示已经进入到项目里了<br>3、在Tab的文件夹里新建一个html文件<br>可以在命令提示框里查看一下现在项目的状态git status，显示的红色的内容就是新添加的文件<br>11、把本地的文件上传到github上<br>1、添加到暂存区(过渡层，避免误操作，保护工作区和版本区)<br>git add 文件名                将单个文件放到暂存区<br>git add .                    将多个文件放到暂存区<br>2、添加到版本区<br>git commit -m ‘注释’            将文件放到版本区<br>git commit -a -m ‘注释’        从本地直接到版本区，跳过了暂存区<br>每一次改动的内容都需要注释一下，容易查看版本<br>3、添加到github上<br>git push origin master<br>这个步骤可能会提示要输入密码，输入注册时候的用户名与密码就可以<br>提交完成后在网页里刷新就能看到提交的文件<br>文件在本地修改的时候，可以随时git status，查看现在的状态</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/23/Markdown-从入门到精通/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Miss huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/23/Markdown-从入门到精通/" itemprop="url">Markdown--从入门到精通</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-23T09:54:16+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote>
<p>Markdown是一种轻量级的标记语言。它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被标记’语言所迷惑。Markdown的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML标记语言来说，Markdown可谓是十分轻量的，学习成本也不需要太多，一旦熟悉这种语法的规则，会有一劳永逸的效果。</p>
</blockquote>
<h2 id="一、认识Markdown"><a href="#一、认识Markdown" class="headerlink" title="一、认识Markdown"></a>一、认识Markdown</h2><hr>
<p>在刚才的导语中提到，Markdown是一种用来写作的轻量级标记语言，它用简介的语法代替排版，而不像一般我们用的字处理软件<em>Word</em>或<em>Pages</em>有大量的排版、字体设置。她使我们专心于码字，用标记语法，来代替常见的格式。例如此文从内容到格式，甚至插图，键盘就可以搞定。目前来看，支持Markdown语法编辑器有很多，包括很多网站也支持Markdown的文字录入。Markdown从写作到完成，导出格式随心所欲。你可以导出HTML格式文件用来网站发布，用Markdown写出简历也可以十分方便导出PDF格式，内容也是用Markdown完成</p>
<h3 id="Markdown官方文档"><a href="#Markdown官方文档" class="headerlink" title="Markdown官方文档"></a>Markdown官方文档</h3><blockquote>
<p>这里可以看到官方的Markdown语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法<br><em>[</em>创始人John Gruber的Markdown语法说明<em>]
</em>[<em>中文文档说明</em>]</p>
</blockquote>
<h3 id="使用Markdown的优点"><a href="#使用Markdown的优点" class="headerlink" title="使用Markdown的优点"></a>使用Markdown的优点</h3><ul>
<li>专注你的文字内容而不是样板样式</li>
<li>轻松导出HTML、PDF和本身的.md文件</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件</li>
<li>可读，直观。适合所有人的写作语言</li>
</ul>
<h3 id="链接图片"><a href="#链接图片" class="headerlink" title="链接图片"></a>链接图片</h3><p><img src="http://a3.topitme.com/1/21/79/1128833621e7779211o.jpg" alt="Mou icon"></p>
<ul>
<li>美女图一</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>&lt;!DOCTYPE html&gt;&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style&gt;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id=&quot;canvas&quot; width=&quot;500&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var canvas=document.getElementById(&#39;canvas&#39;);
            var ctx=canvas.getContext(&quot;2d&quot;);
        &lt;/script&gt;
    &lt;/body&gt;&lt;/html&gt;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Miss huang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Miss huang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
